# 内存泄漏：

内存泄漏是程序设计中一项常见错误，特别是使用没有内置自动垃圾回收的编程语言(C和C++)。一般情况下，内存泄漏发生是因为不能访问动态分配的内存。不过目前有相当数量的调试工具用于检测不能访问的内存，从而可以防止内存泄漏问题。同时垃圾回收机制则可以应用到任何编程语言，而C／C++也有此类库。

- 一个明显的内存泄漏C++程序段

```c++
void f(void)
{
     int *s = new int[50]; // 申请内存空间 
     return; 
     /*  s 指向新分配的堆空间。
     当此函数返回，离开局部变量s的作用域后将无法得知s的值，
     分配的内存空间不能被释放。
    */
 }
 int main(void)
 {
     while (true) f(); // new函数迟早会由于内存泄漏而返回NULL
     return 0;
 }

```

- 一个不太明显的内存泄漏C++程序段

```c++
typedef struct A{
    int a[1000];
    linkA B;
}A,*linkA

void f(A X,int b)
{
     b--;
     if(b==0) return;
     else f(A,b);
     /*这个函数是一个递归函数，
     虽然C中的函数的形式参数会在函数结束的时候释放，
     但是由于这个函数递归层数较多以及X占空间较大，应该很快能耗尽堆栈。
     这也是内存泄漏，实际上只要将参数设为A类型的指针就可以了
    */
 }
 int main(void)
 {
     linkA X= new A;
     int b=100;
     f(X,b);
     delete(X); 
 }

```

内存泄漏会因为减少可用内存的数量从而降低计算机的性能。在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃。不过内存泄漏带来的后果可能是不严重的，有时甚至能够被常规的手段检测出来。而且在现代操作系统中，一个应用程序使用的常规内存在程序终止时被释放。这表示一个短暂运行的应用程序中的内存泄漏不会导致严重后果。

在以下情况，内存泄漏导致较严重的后果：

- 程序运行后置之不理，并且随着时间的流逝消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多内都置之不理）

- 新的内存被频繁地分配，比如当显示电脑游戏或动画视频画面时

- 程序能够请求未被释放的内存,比如共享内存

- 泄漏在操作系统内部发生

- 泄漏在系统关键驱动中发生

- 内存非常有限，比如在嵌入式系统或便携设备中

- 当运行于一个终止时内存并不自动释放的操作系统（比如AmigaOS）之上，而且一旦丢失只能通过重启来恢复

